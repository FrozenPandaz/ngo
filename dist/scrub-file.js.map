{"version":3,"file":"scrub-file.js","sourceRoot":"","sources":["../src/scrub-file.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\r\n\r\n\r\n// Don't remove `ctorParameters` from these.\r\nconst PLATFORM_WHITELIST = [\r\n  'PlatformRef_',\r\n  'TestabilityRegistry',\r\n  'Console',\r\n  'BrowserPlatformLocation',\r\n];\r\n\r\nconst ANGULAR_SPECIFIERS = [\r\n  // Class level decorators.\r\n  'Component',\r\n  'Directive',\r\n  'Injectable',\r\n  'NgModule',\r\n  'Pipe',\r\n\r\n  // Property level decorators.\r\n  'ContentChild',\r\n  'ContentChildren',\r\n  'HostBinding',\r\n  'HostListener',\r\n  'Input',\r\n  'Output',\r\n  'ViewChild',\r\n  'ViewChildren',\r\n];\r\n\r\nexport function getScrubFileTransformer(program: ts.Program): ts.TransformerFactory<ts.SourceFile> {\r\n  const checker = program.getTypeChecker();\r\n\r\n  const foldFileTransform = (context: ts.TransformationContext): ts.Transformer<ts.SourceFile> => {\r\n\r\n    const transformer: ts.Transformer<ts.SourceFile> = (sf: ts.SourceFile) => {\r\n\r\n      const ngMetadata = findAngularMetadata(sf);\r\n      const decorate = findDecorateFunction(sf);\r\n\r\n      const nodes: ts.Node[] = [];\r\n      ts.forEachChild(sf, (node) => {\r\n        if (node.kind !== ts.SyntaxKind.ExpressionStatement) {\r\n          return;\r\n        }\r\n        const exprStmt = node as ts.ExpressionStatement;\r\n        if (isDecoratorAssignmentExpression(exprStmt)) {\r\n          nodes.push(...pickDecorationNodesToRemove(exprStmt, ngMetadata, checker));\r\n        }\r\n        if (isPropDecoratorAssignmentExpression(exprStmt)) {\r\n          nodes.push(...pickPropDecorationNodesToRemove(exprStmt, ngMetadata, checker));\r\n        }\r\n        if (isCtorParamsAssignmentExpression(exprStmt) && !isCtorParamsWhitelistedService(exprStmt)) {\r\n          nodes.push(node);\r\n        }\r\n      });\r\n\r\n      if (!!decorate) {\r\n        const helper = (node: ts.Node) => {\r\n          if (node.kind !== ts.SyntaxKind.ExpressionStatement) {\r\n            ts.forEachChild(node, helper);\r\n            return;\r\n          }\r\n          if (isDecorationAssignment(node as ts.ExpressionStatement, decorate, checker)) {\r\n            const decNodes = pickDecorateNodesToRemove(node as ts.ExpressionStatement, ngMetadata, checker);\r\n            decNodes.forEach((decNode: any) => decNode._comma = true);\r\n            nodes.push(...decNodes);\r\n            return;\r\n          }\r\n          ts.forEachChild(node, helper);\r\n        };\r\n        ts.forEachChild(sf, helper);\r\n      }\r\n\r\n      const visitor: ts.Visitor = (node: ts.Node): ts.Node => {\r\n        // Check if node is a statement to be dropped.\r\n        if (nodes.find((n) => n === node)) {\r\n          return null as any;\r\n        }\r\n\r\n        // Otherwise return node as is.\r\n        return ts.visitEachChild(node, visitor, context);\r\n      };\r\n\r\n      return ts.visitNode(sf, visitor);\r\n    };\r\n    return transformer;\r\n  };\r\n  return foldFileTransform;\r\n}\r\n\r\nexport function expect<T extends ts.Node>(node: ts.Node, kind: ts.SyntaxKind): T {\r\n  if (node.kind !== kind) {\r\n    throw new Error('Invalid!');\r\n  }\r\n  return node as T;\r\n}\r\n\r\nfunction isDecorationAssignment(node: ts.ExpressionStatement, decorate: ts.VariableDeclaration,\r\n  checker: ts.TypeChecker): boolean {\r\n\r\n  if (node.expression.kind !== ts.SyntaxKind.BinaryExpression) {\r\n    return false;\r\n  }\r\n  const binEx = node.expression as ts.BinaryExpression;\r\n\r\n  if (binEx.right.kind !== ts.SyntaxKind.CallExpression) {\r\n    return false;\r\n  }\r\n  const callEx = binEx.right as ts.CallExpression;\r\n\r\n  if (callEx.arguments.length !== 2) {\r\n    return false;\r\n  }\r\n  const arg = callEx.arguments[0];\r\n  if (arg.kind !== ts.SyntaxKind.ArrayLiteralExpression) {\r\n    return false;\r\n  }\r\n\r\n  if (!!callEx.expression && callEx.expression.kind === ts.SyntaxKind.Identifier\r\n    && nodeIsDecorate(callEx.expression, decorate, checker)) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction pickDecorateNodesToRemove(node: ts.ExpressionStatement,\r\n  ngMetadata: ts.Node[], checker: ts.TypeChecker): ts.Node[] {\r\n\r\n  const binEx = expect<ts.BinaryExpression>(node.expression, ts.SyntaxKind.BinaryExpression);\r\n  const callEx = expect<ts.CallExpression>(binEx.right, ts.SyntaxKind.CallExpression);\r\n  const metadata = expect<ts.ArrayLiteralExpression>(callEx.arguments[0], ts.SyntaxKind.ArrayLiteralExpression);\r\n  return metadata.elements.filter((exp) => {\r\n    return isAngularDecoratorCall(exp, ngMetadata, checker);\r\n  });\r\n}\r\n\r\nfunction isAngularDecoratorCall(node: ts.Expression, ngMetadata: ts.Node[], checker: ts.TypeChecker): boolean {\r\n  if (node.kind !== ts.SyntaxKind.CallExpression) {\r\n    return false;\r\n  }\r\n  const callEx = node as ts.CallExpression;\r\n  if (callEx.expression.kind !== ts.SyntaxKind.Identifier) {\r\n    return false;\r\n  }\r\n  const id = callEx.expression as ts.Identifier;\r\n  return identifierIsMetadata(id, ngMetadata, checker);\r\n}\r\n\r\nfunction collectDeepNodes<T>(node: ts.Node, kind: ts.SyntaxKind): T[] {\r\n  const nodes: T[] = [];\r\n  const helper = (child: ts.Node) => {\r\n    if (child.kind === kind) {\r\n      nodes.push(child as any as T);\r\n    }\r\n    ts.forEachChild(child, helper);\r\n  };\r\n  ts.forEachChild(node, helper);\r\n  return nodes;\r\n}\r\n\r\nfunction nameOfSpecifier(node: ts.ImportSpecifier): string {\r\n  return node.name && node.name.text || '<unknown>';\r\n}\r\n\r\nfunction findAngularMetadata(node: ts.Node): ts.Node[] {\r\n  let specs: ts.Node[] = [];\r\n  ts.forEachChild(node, (child) => {\r\n    if (child.kind === ts.SyntaxKind.ImportDeclaration) {\r\n      const importDecl = child as ts.ImportDeclaration;\r\n      if (isAngularCoreImport(importDecl)) {\r\n        specs.push(...collectDeepNodes<ts.ImportSpecifier>(node, ts.SyntaxKind.ImportSpecifier)\r\n          .filter((spec) => isAngularCoreSpecifier(spec)));\r\n      }\r\n    }\r\n  });\r\n\r\n  const localDecl = findAllDeclarations(node)\r\n    .filter((decl) => ANGULAR_SPECIFIERS.indexOf((decl.name as ts.Identifier).text) !== -1);\r\n  if (localDecl.length === ANGULAR_SPECIFIERS.length) {\r\n    specs = specs.concat(localDecl);\r\n  }\r\n\r\n  return specs;\r\n}\r\n\r\nfunction findAllDeclarations(node: ts.Node): ts.VariableDeclaration[] {\r\n  const nodes: ts.VariableDeclaration[] = [];\r\n  ts.forEachChild(node, (child) => {\r\n    if (child.kind === ts.SyntaxKind.VariableStatement) {\r\n      const vStmt = child as ts.VariableStatement;\r\n      vStmt.declarationList.declarations.forEach((decl) => {\r\n        if (decl.name.kind !== ts.SyntaxKind.Identifier) {\r\n          return;\r\n        }\r\n        nodes.push(decl);\r\n      });\r\n    }\r\n  });\r\n  return nodes;\r\n}\r\n\r\nfunction findDecorateFunction(node: ts.Node): ts.VariableDeclaration | null {\r\n  let decl: ts.VariableDeclaration | null = null;\r\n  ts.forEachChild(node, (child) => {\r\n    if (child.kind !== ts.SyntaxKind.VariableStatement) {\r\n      return;\r\n    }\r\n    collectDeepNodes<ts.VariableDeclaration>(child, ts.SyntaxKind.VariableDeclaration).forEach((declChild) => {\r\n      if (declChild.name.kind !== ts.SyntaxKind.Identifier) {\r\n        return;\r\n      }\r\n      if ((declChild.name as ts.Identifier).text === '___decorate' &&\r\n        collectDeepNodes<ts.PropertyAccessExpression>(declChild, ts.SyntaxKind.PropertyAccessExpression)\r\n          .some(isReflectDecorateMethod)) {\r\n        decl = declChild;\r\n      }\r\n    });\r\n  });\r\n  return decl;\r\n}\r\n\r\nfunction isReflectDecorateMethod(node: ts.PropertyAccessExpression): boolean {\r\n  if (node.expression.kind !== ts.SyntaxKind.Identifier || node.name.kind !== ts.SyntaxKind.Identifier) {\r\n    return false;\r\n  }\r\n  return (node.expression as ts.Identifier).text === 'Reflect' && (node.name as ts.Identifier).text === 'decorate';\r\n}\r\n\r\nfunction isAngularCoreImport(node: ts.ImportDeclaration): boolean {\r\n  return true &&\r\n    node.moduleSpecifier &&\r\n    node.moduleSpecifier.kind === ts.SyntaxKind.StringLiteral &&\r\n    (node.moduleSpecifier as ts.StringLiteral).text === '@angular/core';\r\n}\r\n\r\nfunction isAngularCoreSpecifier(node: ts.ImportSpecifier): boolean {\r\n  return ANGULAR_SPECIFIERS.indexOf(nameOfSpecifier(node)) !== -1;\r\n}\r\n\r\nfunction isDecoratorAssignmentExpression(exprStmt: ts.ExpressionStatement): boolean {\r\n  if (exprStmt.expression.kind !== ts.SyntaxKind.BinaryExpression) {\r\n    return false;\r\n  }\r\n  const expr = exprStmt.expression as ts.BinaryExpression;\r\n  if (expr.left.kind !== ts.SyntaxKind.PropertyAccessExpression) {\r\n    return false;\r\n  }\r\n  const propAccess = expr.left as ts.PropertyAccessExpression;\r\n  if (propAccess.expression.kind !== ts.SyntaxKind.Identifier) {\r\n    return false;\r\n  }\r\n  if (propAccess.name.text !== 'decorators') {\r\n    return false;\r\n  }\r\n  if (expr.operatorToken.kind !== ts.SyntaxKind.FirstAssignment) {\r\n    return false;\r\n  }\r\n  if (expr.right.kind !== ts.SyntaxKind.ArrayLiteralExpression) {\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction isPropDecoratorAssignmentExpression(exprStmt: ts.ExpressionStatement): boolean {\r\n  if (exprStmt.expression.kind !== ts.SyntaxKind.BinaryExpression) {\r\n    return false;\r\n  }\r\n  const expr = exprStmt.expression as ts.BinaryExpression;\r\n  if (expr.left.kind !== ts.SyntaxKind.PropertyAccessExpression) {\r\n    return false;\r\n  }\r\n  const propAccess = expr.left as ts.PropertyAccessExpression;\r\n  if (propAccess.expression.kind !== ts.SyntaxKind.Identifier) {\r\n    return false;\r\n  }\r\n  if (propAccess.name.text !== 'propDecorators') {\r\n    return false;\r\n  }\r\n  if (expr.operatorToken.kind !== ts.SyntaxKind.FirstAssignment) {\r\n    return false;\r\n  }\r\n  if (expr.right.kind !== ts.SyntaxKind.ObjectLiteralExpression) {\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction isCtorParamsAssignmentExpression(exprStmt: ts.ExpressionStatement): boolean {\r\n  if (exprStmt.expression.kind !== ts.SyntaxKind.BinaryExpression) {\r\n    return false;\r\n  }\r\n  const expr = exprStmt.expression as ts.BinaryExpression;\r\n  if (expr.left.kind !== ts.SyntaxKind.PropertyAccessExpression) {\r\n    return false;\r\n  }\r\n  const propAccess = expr.left as ts.PropertyAccessExpression;\r\n  if (propAccess.name.text !== 'ctorParameters') {\r\n    return false;\r\n  }\r\n  if (propAccess.expression.kind !== ts.SyntaxKind.Identifier) {\r\n    return false;\r\n  }\r\n  if (expr.operatorToken.kind !== ts.SyntaxKind.FirstAssignment) {\r\n    return false;\r\n  }\r\n  if (expr.right.kind !== ts.SyntaxKind.FunctionExpression) {\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction isCtorParamsWhitelistedService(exprStmt: ts.ExpressionStatement): boolean {\r\n  const expr = exprStmt.expression as ts.BinaryExpression;\r\n  const propAccess = expr.left as ts.PropertyAccessExpression;\r\n  const serviceId = propAccess.expression as ts.Identifier;\r\n  return PLATFORM_WHITELIST.indexOf(serviceId.text) !== -1;\r\n}\r\n\r\nfunction pickDecorationNodesToRemove(exprStmt: ts.ExpressionStatement, ngMetadata: ts.Node[],\r\n  checker: ts.TypeChecker): ts.Node[] {\r\n\r\n  const expr = expect<ts.BinaryExpression>(exprStmt.expression, ts.SyntaxKind.BinaryExpression);\r\n  const literal = expect<ts.ArrayLiteralExpression>(expr.right, ts.SyntaxKind.ArrayLiteralExpression);\r\n  if (!literal.elements.every((elem) => elem.kind === ts.SyntaxKind.ObjectLiteralExpression)) {\r\n    return [];\r\n  }\r\n  const elements = literal.elements as ts.Node[] as ts.ObjectLiteralExpression[];\r\n  const ngDecorators = elements.filter((elem) => isAngularDecorator(elem, ngMetadata, checker));\r\n  return (elements.length > ngDecorators.length) ? ngDecorators : [exprStmt];\r\n}\r\n\r\nfunction pickPropDecorationNodesToRemove(exprStmt: ts.ExpressionStatement, ngMetadata: ts.Node[],\r\n  checker: ts.TypeChecker): ts.Node[] {\r\n\r\n  const expr = expect<ts.BinaryExpression>(exprStmt.expression, ts.SyntaxKind.BinaryExpression);\r\n  const literal = expect<ts.ObjectLiteralExpression>(expr.right, ts.SyntaxKind.ObjectLiteralExpression);\r\n  if (!literal.properties.every((elem) => elem.kind === ts.SyntaxKind.PropertyAssignment &&\r\n    (elem as ts.PropertyAssignment).initializer.kind === ts.SyntaxKind.ArrayLiteralExpression)) {\r\n    return [];\r\n  }\r\n  const assignments = literal.properties as ts.Node[] as ts.PropertyAssignment[];\r\n  // Consider each assignment individually. Either the whole assignment will be removed or\r\n  // a particular decorator within will.\r\n  const toRemove = assignments\r\n    .map((assign) => {\r\n      const decorators =\r\n        expect<ts.ArrayLiteralExpression>(assign.initializer, ts.SyntaxKind.ArrayLiteralExpression).elements;\r\n      if (!decorators.every((el) => el.kind === ts.SyntaxKind.ObjectLiteralExpression)) {\r\n        return [];\r\n      }\r\n      const decsToRemove = decorators.filter((expression) => {\r\n        const lit = expect<ts.ObjectLiteralExpression>(expression, ts.SyntaxKind.ObjectLiteralExpression);\r\n        return isAngularDecorator(lit, ngMetadata, checker);\r\n      });\r\n      if (decsToRemove.length === decorators.length) {\r\n        return [assign];\r\n      }\r\n      return decsToRemove;\r\n    })\r\n    .reduce((accum, toRm) => accum.concat(toRm), [] as ts.Node[]);\r\n  // If every node to be removed is a property assignment (full property's decorators) and\r\n  // all properties are accounted for, remove the whole assignment. Otherwise, remove the\r\n  // nodes which were marked as safe.\r\n  if (toRemove.length === assignments.length &&\r\n    toRemove.every((node) => node.kind === ts.SyntaxKind.PropertyAssignment)) {\r\n    return [exprStmt];\r\n  }\r\n  return toRemove;\r\n}\r\n\r\nfunction isAngularDecorator(literal: ts.ObjectLiteralExpression, ngMetadata: ts.Node[],\r\n  checker: ts.TypeChecker): boolean {\r\n\r\n  const types = literal.properties.filter(isTypeProperty);\r\n  if (types.length !== 1) {\r\n    return false;\r\n  }\r\n  const assign = expect<ts.PropertyAssignment>(types[0], ts.SyntaxKind.PropertyAssignment);\r\n  if (assign.initializer.kind !== ts.SyntaxKind.Identifier) {\r\n    return false;\r\n  }\r\n  const id = assign.initializer as ts.Identifier;\r\n  const res = identifierIsMetadata(id, ngMetadata, checker);\r\n  return res;\r\n}\r\n\r\nfunction isTypeProperty(prop: ts.ObjectLiteralElement): boolean {\r\n  if (prop.kind !== ts.SyntaxKind.PropertyAssignment) {\r\n    return false;\r\n  }\r\n  const assignment = prop as ts.PropertyAssignment;\r\n  if (assignment.name.kind !== ts.SyntaxKind.Identifier) {\r\n    return false;\r\n  }\r\n  const name = assignment.name as ts.Identifier;\r\n  return name.text === 'type';\r\n}\r\n\r\n// Check if an identifier is part of the known Angular Metadata.\r\nfunction identifierIsMetadata(id: ts.Identifier, metadata: ts.Node[], checker: ts.TypeChecker): boolean {\r\n  const symbol = checker.getSymbolAtLocation(id);\r\n  if (!symbol || !symbol.declarations || !symbol.declarations.length) {\r\n    return false;\r\n  }\r\n  return symbol\r\n    .declarations\r\n    .some((spec) => metadata.indexOf(spec) !== -1);\r\n}\r\n\r\nfunction nodeIsDecorate(node: ts.Node, decorate: ts.VariableDeclaration, checker: ts.TypeChecker): boolean {\r\n  const symbol = checker.getSymbolAtLocation(node);\r\n  if (!symbol || !symbol.declarations || !symbol.declarations.length) {\r\n    return false;\r\n  }\r\n  return symbol\r\n    .declarations\r\n    .some((spec) => spec === decorate);\r\n}\r\n"]}